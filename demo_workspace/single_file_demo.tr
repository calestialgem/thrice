##! This is an inner documentation. It documents the entity that surrounds it,
##! which is the `single_file_demo` package/module in this case.
##!
##! This is a demo Thrice program that uses all the language features that could
##! fit in a single file. Written by Cem Ge√ßgel <gecgelcem@outlook.com>.

## This is a normal documentation. It documents the entity that fallows it,
## which is the `entrypoint` declaration in this case.
##
## `entrypoint` is the same as the main function in a C program.

entrypoint
{
  # This is a normal comment, it is not a documentation.
  #
  # Fallowing is an exhaustive list of valid expressions in the language.
}

## A class is a predicate for types. Class defines functions that must be
## provided by a type. User defined types declare themselves as a member of the
## class, and implement the functions. Built-in types can be made a member only
## by the class itself.
##
## Classes are used for compile-time polymorphism.
##
## Fallowing is a class that requires a function named `add` that takes two
## parameters with its type and return a result with its type. Then, the class
## is implemented for all the built-in types.
class Addable
{
  ## A function declaration starts with keyword `func`; then comes the name.
  ## After that, is the comma separated list of parameters. Function declaration
  ## ends with the return type if there is any and a terminating semicolon.
  ##
  ## `self` keyword refers to the enclosing type. In a class, the enclosing type
  ## is the type that implements the class.
  func add(self l, self r) self;

  ## A class might provide a default implementation. This is done with a
  ## function definition instead of just a declaration. A function definition is
  ## very similar to a declaration. The only difference is it has the function
  ## body, which is a list of statements instead of a semicolon.
  func addItself(self it) self { return add(it, it); }

  # In the implementation of a class for a built-in type, the type comes after
  # `implements` keyword. Then, a scope is entered, which has the function
  # definitions. Functions defined like this must solely consist of the ones
  # required by the class. Furthermore, the superclasses of the class, if there
  # is any, must also be implemented for the built-in types that the class is
  # implemented for.

  implements bool   { func add(bool l,   bool r)   bool   { return l || r; }}
  implements byte   { func add(byte l,   byte r)   byte   { return l +  r; }}
  implements int    { func add(int l,    int r)    int    { return l +  r; }}
  implements uint   { func add(uint l,   uint r)   uint   { return l +  r; }}
  implements long   { func add(long l,   long r)   long   { return l +  r; }}
  implements ulong  { func add(ulong l,  ulong r)  ulong  { return l +  r; }}
  implements float  { func add(float l,  float r)  float  { return l +  r; }}
  implements double { func add(double l, double r) double { return l +  r; }}
}

## Classes can have superclasses. All types implementing a subclass must also
## implement all the superclasses. This means, a subclass might only implement
## itself for a built-in type if all its superclasses also provide an
## implementation for that built-in type.
class Superposable extends Addable
{
  func superpose(self left, self right) self { return add(left, right); }
}

## A struct is a product type that is composed of members of other types. Also,
## types can have functions in them that are namespaced under them. Types can be
## declared to be a member of some classes; in that case, they have to provide
## functions required by all the classes they are declared to be in.
struct Vector(float x, float y) implements Addable
{
  func add(self l, self r) self { return self(l.x + r.x, l.y + r.y); }
}

## An enum is a type with distinct and limited values called constants.
enum Cardinal(NORTH, SOUTH, EAST, WEST)
{
  func toVector(self cardinal) Vector
  {
    switch (cardinal)
    {
      case (NORTH) return Vector(0, +1);
      case (SOUTH) return Vector(0, -1);
      case (EAST) return Vector(+1, 0);
      case (WEST) return Vector(-1, 0);
    }
  }
}

## A union is a sum type that can be one of the alternatives.
union Direction(Vector, Cardinal)
{
  func invert(self direction) self
  {
    switch (direction)
    {
      case (Vector vector) return Vector(-vector.x, -vector.y);
      case (Cardinal cardinal)
      {
        switch (cardinal)
        {
          case (NORTH) return SOUTH;
          case (SOUTH) return NORTH;
          case (EAST) return EAST;
          case (WEST) return WEST;
        }
      }
    }
  }
}
